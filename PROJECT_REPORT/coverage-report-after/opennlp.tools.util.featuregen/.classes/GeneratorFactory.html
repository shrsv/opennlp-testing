


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: GeneratorFactory</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">opennlp.tools.util.featuregen</a> ]
</div>

<h1>Coverage Summary for Class: GeneratorFactory (opennlp.tools.util.featuregen)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GeneratorFactory</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68%
  </span>
  <span class="absValue">
    (123/ 181)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GeneratorFactory$AbstractXmlFeatureGeneratorFactory</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.9%
  </span>
  <span class="absValue">
    (70/ 115)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GeneratorFactory$CustomFeatureGeneratorFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (15/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GeneratorFactory$XmlFeatureGeneratorFactory</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    75.9%
  </span>
  <span class="absValue">
    (22/ 29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.5%
  </span>
  <span class="absValue">
    (208/ 313)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>3</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>5</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>6</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>7</i>&nbsp; * the License. You may obtain a copy of the License at
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>12</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>13</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>14</i>&nbsp; * See the License for the specific language governing permissions and
<i>15</i>&nbsp; * limitations under the License.
<i>16</i>&nbsp; */
<i>17</i>&nbsp;
<i>18</i>&nbsp;package opennlp.tools.util.featuregen;
<i>19</i>&nbsp;
<i>20</i>&nbsp;import java.io.IOException;
<i>21</i>&nbsp;import java.io.InputStream;
<i>22</i>&nbsp;import java.lang.reflect.Constructor;
<i>23</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>24</i>&nbsp;import java.util.ArrayList;
<i>25</i>&nbsp;import java.util.HashMap;
<i>26</i>&nbsp;import java.util.LinkedHashMap;
<i>27</i>&nbsp;import java.util.List;
<i>28</i>&nbsp;import java.util.Map;
<i>29</i>&nbsp;
<i>30</i>&nbsp;import javax.xml.parsers.DocumentBuilder;
<i>31</i>&nbsp;import javax.xml.xpath.XPath;
<i>32</i>&nbsp;import javax.xml.xpath.XPathConstants;
<i>33</i>&nbsp;import javax.xml.xpath.XPathExpression;
<i>34</i>&nbsp;import javax.xml.xpath.XPathExpressionException;
<i>35</i>&nbsp;import javax.xml.xpath.XPathFactory;
<i>36</i>&nbsp;
<i>37</i>&nbsp;import org.w3c.dom.Element;
<i>38</i>&nbsp;import org.w3c.dom.NamedNodeMap;
<i>39</i>&nbsp;import org.w3c.dom.Node;
<i>40</i>&nbsp;import org.w3c.dom.NodeList;
<i>41</i>&nbsp;import org.w3c.dom.Text;
<i>42</i>&nbsp;import org.xml.sax.SAXException;
<i>43</i>&nbsp;
<i>44</i>&nbsp;import opennlp.tools.util.InvalidFormatException;
<i>45</i>&nbsp;import opennlp.tools.util.XmlUtil;
<i>46</i>&nbsp;import opennlp.tools.util.ext.ExtensionLoader;
<i>47</i>&nbsp;import opennlp.tools.util.model.ArtifactSerializer;
<i>48</i>&nbsp;import opennlp.tools.util.model.DictionarySerializer;
<i>49</i>&nbsp;import opennlp.tools.util.model.POSModelSerializer;
<i>50</i>&nbsp;
<i>51</i>&nbsp;/**
<i>52</i>&nbsp; * Creates a set of feature generators based on a provided XML descriptor.
<i>53</i>&nbsp; *
<i>54</i>&nbsp; * Example of an XML descriptor:
<i>55</i>&nbsp; * &lt;p&gt;
<i>56</i>&nbsp; * &amp;lt;featureGenerators name=&quot;namefind&quot;&amp;gt;
<i>57</i>&nbsp; *     &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.CachedFeatureGeneratorFactory&quot;&amp;gt;
<i>58</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.WindowFeatureGeneratorFactory&quot;&amp;gt;
<i>59</i>&nbsp; *           &amp;lt;int name=&quot;prevLength&quot;&amp;gt;2&amp;lt;/int&amp;gt;
<i>60</i>&nbsp; *           &amp;lt;int name=&quot;nextLength&quot;&amp;gt;2&amp;lt;/int&amp;gt;
<i>61</i>&nbsp; *           &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.TokenClassFeatureGeneratorFactory&quot;/&amp;gt;
<i>62</i>&nbsp; *         &amp;lt;/generator&amp;gt;
<i>63</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.WindowFeatureGeneratorFactory&quot;&amp;gt;
<i>64</i>&nbsp; *           &amp;lt;int name=&quot;prevLength&quot;&amp;gt;2&amp;lt;/int&amp;gt;
<i>65</i>&nbsp; *           &amp;lt;int name=&quot;nextLength&quot;&amp;gt;2&amp;lt;/int&amp;gt;
<i>66</i>&nbsp; *           &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.TokenFeatureGeneratorFactory&quot;/&amp;gt;
<i>67</i>&nbsp; *         &amp;lt;/generator&amp;gt;
<i>68</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.DefinitionFeatureGeneratorFactory&quot;/&amp;gt;
<i>69</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.PreviousMapFeatureGeneratorFactory&quot;/&amp;gt;
<i>70</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.BigramNameFeatureGeneratorFactory&quot;/&amp;gt;
<i>71</i>&nbsp; *         &amp;lt;generator class=&quot;opennlp.tools.util.featuregen.SentenceFeatureGeneratorFactory&quot;&amp;gt;
<i>72</i>&nbsp; *           &amp;lt;bool name=&quot;begin&quot;&amp;gt;true&amp;lt;/bool&amp;gt;
<i>73</i>&nbsp; *           &amp;lt;bool name=&quot;end&quot;&amp;gt;false&amp;lt;/bool&amp;gt;
<i>74</i>&nbsp; *         &amp;lt;/generator&amp;gt;
<i>75</i>&nbsp; *     &amp;lt;/generator&amp;gt;
<i>76</i>&nbsp; * &amp;lt;/featureGenerators&amp;gt;
<i>77</i>&nbsp; * &lt;/p&gt;
<i>78</i>&nbsp; *
<i>79</i>&nbsp; * Each XML element is mapped to a {@link GeneratorFactory.XmlFeatureGeneratorFactory} which
<i>80</i>&nbsp; * is responsible to process the element and create the specified
<i>81</i>&nbsp; * {@link AdaptiveFeatureGenerator}. Elements can contain other
<i>82</i>&nbsp; * elements in this case it is the responsibility of the mapped factory to process
<i>83</i>&nbsp; * the child elements correctly. In some factories this leads to recursive
<i>84</i>&nbsp; * calls the
<i>85</i>&nbsp; * {@link GeneratorFactory.XmlFeatureGeneratorFactory#create(Element, FeatureGeneratorResourceProvider)}
<i>86</i>&nbsp; * method.
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * In the example above the generators element is mapped to the
<i>89</i>&nbsp; * {@link AggregatedFeatureGeneratorFactory} which then
<i>90</i>&nbsp; * creates all the aggregated {@link AdaptiveFeatureGenerator}s to
<i>91</i>&nbsp; * accomplish this it evaluates the mapping with the same mechanism
<i>92</i>&nbsp; * and gives the child element to the corresponding factories. All
<i>93</i>&nbsp; * created generators are added to a new instance of the
<i>94</i>&nbsp; * {@link AggregatedFeatureGenerator} which is then returned.
<i>95</i>&nbsp; */
<b class="nc"><i>96</i>&nbsp;public class GeneratorFactory {</b>
<i>97</i>&nbsp;
<i>98</i>&nbsp;  /**
<i>99</i>&nbsp;   * The {@link XmlFeatureGeneratorFactory} is responsible to construct
<i>100</i>&nbsp;   * an {@link AdaptiveFeatureGenerator} from an given XML {@link Element}
<i>101</i>&nbsp;   * which contains all necessary configuration if any.
<i>102</i>&nbsp;   */
<i>103</i>&nbsp;  @Deprecated // TODO: (OPENNLP-1174) just remove when back-compat is no longer needed
<i>104</i>&nbsp;  interface XmlFeatureGeneratorFactory {
<i>105</i>&nbsp;
<i>106</i>&nbsp;    /**
<i>107</i>&nbsp;     * Creates an {@link AdaptiveFeatureGenerator} from a the describing
<i>108</i>&nbsp;     * XML element.
<i>109</i>&nbsp;     *
<i>110</i>&nbsp;     * @param generatorElement the element which contains the configuration
<i>111</i>&nbsp;     * @param resourceManager the resource manager which could be used
<i>112</i>&nbsp;     *     to access referenced resources
<i>113</i>&nbsp;     *
<i>114</i>&nbsp;     * @return the configured {@link AdaptiveFeatureGenerator}
<i>115</i>&nbsp;     */
<i>116</i>&nbsp;    AdaptiveFeatureGenerator create(Element generatorElement,
<i>117</i>&nbsp;        FeatureGeneratorResourceProvider resourceManager) throws InvalidFormatException;
<i>118</i>&nbsp;  }
<i>119</i>&nbsp;
<i>120</i>&nbsp;  public static abstract class AbstractXmlFeatureGeneratorFactory {
<i>121</i>&nbsp;
<i>122</i>&nbsp;    protected Element generatorElement;
<i>123</i>&nbsp;    protected FeatureGeneratorResourceProvider resourceManager;
<i>124</i>&nbsp;
<i>125</i>&nbsp;    // to respect the order &lt;generator/&gt; in AggregatedFeatureGenerator, let&#39;s use LinkedHashMap
<i>126</i>&nbsp;    protected LinkedHashMap&lt;String, Object&gt; args;
<i>127</i>&nbsp;
<b class="fc"><i>128</i>&nbsp;    public AbstractXmlFeatureGeneratorFactory() {</b>
<b class="fc"><i>129</i>&nbsp;      args = new LinkedHashMap&lt;&gt;();</b>
<b class="fc"><i>130</i>&nbsp;    }</b>
<i>131</i>&nbsp;
<i>132</i>&nbsp;    public Map&lt;String, ArtifactSerializer&lt;?&gt;&gt;
<i>133</i>&nbsp;        getArtifactSerializerMapping() throws InvalidFormatException {
<b class="fc"><i>134</i>&nbsp;      return null;</b>
<i>135</i>&nbsp;    }
<i>136</i>&nbsp;
<i>137</i>&nbsp;    final void init(Element element, FeatureGeneratorResourceProvider resourceManager)
<i>138</i>&nbsp;        throws InvalidFormatException {
<b class="fc"><i>139</i>&nbsp;      this.generatorElement = element;</b>
<b class="fc"><i>140</i>&nbsp;      this.resourceManager = resourceManager;</b>
<b class="fc"><i>141</i>&nbsp;      List&lt;AdaptiveFeatureGenerator&gt; generators = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>142</i>&nbsp;      NodeList childNodes = generatorElement.getChildNodes();</b>
<b class="fc"><i>143</i>&nbsp;      for (int i = 0; i &lt; childNodes.getLength(); i++) {</b>
<b class="fc"><i>144</i>&nbsp;        Node childNode = childNodes.item(i);</b>
<b class="fc"><i>145</i>&nbsp;        if (childNode instanceof Element) {</b>
<b class="fc"><i>146</i>&nbsp;          Element elem = (Element)childNode;</b>
<b class="fc"><i>147</i>&nbsp;          String type = elem.getTagName();</b>
<b class="fc"><i>148</i>&nbsp;          if (type.equals(&quot;generator&quot;)) {</b>
<b class="fc"><i>149</i>&nbsp;            String key = &quot;generator#&quot; + Integer.toString(generators.size());</b>
<b class="fc"><i>150</i>&nbsp;            AdaptiveFeatureGenerator afg = buildGenerator(elem, resourceManager);</b>
<b class="fc"><i>151</i>&nbsp;            generators.add(afg);</b>
<b class="fc"><i>152</i>&nbsp;            if (afg != null)</b>
<b class="fc"><i>153</i>&nbsp;              args.put(key, afg);</b>
<b class="fc"><i>154</i>&nbsp;          }</b>
<i>155</i>&nbsp;          else {
<b class="fc"><i>156</i>&nbsp;            String name = elem.getAttribute(&quot;name&quot;);</b>
<b class="fc"><i>157</i>&nbsp;            Node cn = elem.getFirstChild();</b>
<b class="fc"><i>158</i>&nbsp;            Text text = (Text)cn;</b>
<i>159</i>&nbsp;
<b class="fc"><i>160</i>&nbsp;            switch (type) {</b>
<i>161</i>&nbsp;              case &quot;int&quot; :
<b class="fc"><i>162</i>&nbsp;                args.put(name, Integer.parseInt(text.getWholeText()));</b>
<b class="fc"><i>163</i>&nbsp;                break;</b>
<i>164</i>&nbsp;              case &quot;long&quot; :
<b class="fc"><i>165</i>&nbsp;                args.put(name, Long.parseLong(text.getWholeText()));</b>
<b class="fc"><i>166</i>&nbsp;                break;</b>
<i>167</i>&nbsp;              case &quot;float&quot; :
<b class="fc"><i>168</i>&nbsp;                args.put(name, Float.parseFloat(text.getWholeText()));</b>
<b class="fc"><i>169</i>&nbsp;                break;</b>
<i>170</i>&nbsp;              case &quot;double&quot; :
<b class="fc"><i>171</i>&nbsp;                args.put(name, Double.parseDouble(text.getWholeText()));</b>
<b class="fc"><i>172</i>&nbsp;                break;</b>
<i>173</i>&nbsp;              case &quot;str&quot; :
<b class="fc"><i>174</i>&nbsp;                args.put(name, text.getWholeText());</b>
<b class="fc"><i>175</i>&nbsp;                break;</b>
<i>176</i>&nbsp;              case &quot;bool&quot; :
<b class="fc"><i>177</i>&nbsp;                args.put(name, Boolean.parseBoolean(text.getWholeText()));</b>
<b class="fc"><i>178</i>&nbsp;                break;</b>
<i>179</i>&nbsp;              default:
<b class="nc"><i>180</i>&nbsp;                throw new InvalidFormatException(</b>
<i>181</i>&nbsp;                    &quot;child element must be one of generator, int, long, float, double,&quot; +
<i>182</i>&nbsp;                        &quot; str or bool&quot;);
<i>183</i>&nbsp;            }
<i>184</i>&nbsp;          }
<i>185</i>&nbsp;        }
<i>186</i>&nbsp;      }
<i>187</i>&nbsp;
<b class="fc"><i>188</i>&nbsp;      if (generators.size() &gt; 1) {</b>
<b class="nc"><i>189</i>&nbsp;        AdaptiveFeatureGenerator aggregatedFeatureGenerator =</b>
<b class="nc"><i>190</i>&nbsp;            new AggregatedFeatureGenerator(generators.toArray(</b>
<b class="nc"><i>191</i>&nbsp;                new AdaptiveFeatureGenerator[generators.size()]));</b>
<b class="nc"><i>192</i>&nbsp;        args.put(&quot;generator#0&quot;, aggregatedFeatureGenerator);</b>
<i>193</i>&nbsp;      }
<b class="fc"><i>194</i>&nbsp;    }</b>
<i>195</i>&nbsp;
<i>196</i>&nbsp;    public int getInt(String name) throws InvalidFormatException {
<b class="fc"><i>197</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>198</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>199</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>200</i>&nbsp;      }
<b class="fc"><i>201</i>&nbsp;      else if (value instanceof Integer) {</b>
<b class="fc"><i>202</i>&nbsp;        return (Integer)value;</b>
<i>203</i>&nbsp;      }
<i>204</i>&nbsp;      else {
<b class="nc"><i>205</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be integer!&quot;);</b>
<i>206</i>&nbsp;      }
<i>207</i>&nbsp;    }
<i>208</i>&nbsp;
<i>209</i>&nbsp;    public int getInt(String name, int defValue) throws InvalidFormatException {
<b class="fc"><i>210</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>211</i>&nbsp;      if (value == null) {</b>
<b class="fc"><i>212</i>&nbsp;        return defValue;</b>
<i>213</i>&nbsp;      }
<b class="nc"><i>214</i>&nbsp;      else if (value instanceof Integer) {</b>
<b class="nc"><i>215</i>&nbsp;        return (Integer)value;</b>
<i>216</i>&nbsp;      }
<i>217</i>&nbsp;      else {
<b class="nc"><i>218</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be integer!&quot;);</b>
<i>219</i>&nbsp;      }
<i>220</i>&nbsp;    }
<i>221</i>&nbsp;
<i>222</i>&nbsp;    public long getLong(String name) throws InvalidFormatException {
<b class="fc"><i>223</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>224</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>225</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>226</i>&nbsp;      }
<b class="fc"><i>227</i>&nbsp;      else if (value instanceof Long) {</b>
<b class="fc"><i>228</i>&nbsp;        return (Long)value;</b>
<i>229</i>&nbsp;      }
<i>230</i>&nbsp;      else {
<b class="nc"><i>231</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be long!&quot;);</b>
<i>232</i>&nbsp;      }
<i>233</i>&nbsp;    }
<i>234</i>&nbsp;
<i>235</i>&nbsp;    public long getLong(String name, long defValue) throws InvalidFormatException {
<b class="nc"><i>236</i>&nbsp;      Object value = args.get(name);</b>
<b class="nc"><i>237</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>238</i>&nbsp;        return defValue;</b>
<i>239</i>&nbsp;      }
<b class="nc"><i>240</i>&nbsp;      else if (value instanceof Long) {</b>
<b class="nc"><i>241</i>&nbsp;        return (Long)value;</b>
<i>242</i>&nbsp;      }
<i>243</i>&nbsp;      else {
<b class="nc"><i>244</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be long!&quot;);</b>
<i>245</i>&nbsp;      }
<i>246</i>&nbsp;    }
<i>247</i>&nbsp;
<i>248</i>&nbsp;    public float getFloat(String name) throws InvalidFormatException {
<b class="fc"><i>249</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>250</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>251</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>252</i>&nbsp;      }
<b class="fc"><i>253</i>&nbsp;      else if (value instanceof Float) {</b>
<b class="fc"><i>254</i>&nbsp;        return (Float)value;</b>
<i>255</i>&nbsp;      }
<i>256</i>&nbsp;      else {
<b class="nc"><i>257</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be float!&quot;);</b>
<i>258</i>&nbsp;      }
<i>259</i>&nbsp;    }
<i>260</i>&nbsp;
<i>261</i>&nbsp;    public float getFloat(String name, float defValue) throws InvalidFormatException {
<b class="nc"><i>262</i>&nbsp;      Object value = args.get(name);</b>
<b class="nc"><i>263</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>264</i>&nbsp;        return defValue;</b>
<i>265</i>&nbsp;      }
<b class="nc"><i>266</i>&nbsp;      else if (value instanceof Float) {</b>
<b class="nc"><i>267</i>&nbsp;        return (Float)value;</b>
<i>268</i>&nbsp;      }
<i>269</i>&nbsp;      else {
<b class="nc"><i>270</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be float!&quot;);</b>
<i>271</i>&nbsp;      }
<i>272</i>&nbsp;    }
<i>273</i>&nbsp;
<i>274</i>&nbsp;    public double getDouble(String name) throws InvalidFormatException {
<b class="fc"><i>275</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>276</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>277</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>278</i>&nbsp;      }
<b class="fc"><i>279</i>&nbsp;      else if (value instanceof Double) {</b>
<b class="fc"><i>280</i>&nbsp;        return (Double)value;</b>
<i>281</i>&nbsp;      }
<i>282</i>&nbsp;      else {
<b class="nc"><i>283</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be double!&quot;);</b>
<i>284</i>&nbsp;      }
<i>285</i>&nbsp;    }
<i>286</i>&nbsp;
<i>287</i>&nbsp;    public double getDouble(String name, double defValue) throws InvalidFormatException {
<b class="nc"><i>288</i>&nbsp;      Object value = args.get(name);</b>
<b class="nc"><i>289</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>290</i>&nbsp;        return defValue;</b>
<i>291</i>&nbsp;      }
<b class="nc"><i>292</i>&nbsp;      else if (value instanceof Double) {</b>
<b class="nc"><i>293</i>&nbsp;        return (Double)value;</b>
<i>294</i>&nbsp;      }
<i>295</i>&nbsp;      else {
<b class="nc"><i>296</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be double!&quot;);</b>
<i>297</i>&nbsp;      }
<i>298</i>&nbsp;    }
<i>299</i>&nbsp;
<i>300</i>&nbsp;    public String getStr(String name) throws InvalidFormatException {
<b class="fc"><i>301</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>302</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>303</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>304</i>&nbsp;      }
<b class="fc"><i>305</i>&nbsp;      else if (value instanceof String) {</b>
<b class="fc"><i>306</i>&nbsp;        return (String)value;</b>
<i>307</i>&nbsp;      }
<i>308</i>&nbsp;      else {
<b class="nc"><i>309</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be double!&quot;);</b>
<i>310</i>&nbsp;      }
<i>311</i>&nbsp;    }
<i>312</i>&nbsp;
<i>313</i>&nbsp;    public String getStr(String name, String defValue) throws InvalidFormatException {
<b class="nc"><i>314</i>&nbsp;      Object value = args.get(name);</b>
<b class="nc"><i>315</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>316</i>&nbsp;        return defValue;</b>
<i>317</i>&nbsp;      }
<b class="nc"><i>318</i>&nbsp;      else if (value instanceof String) {</b>
<b class="nc"><i>319</i>&nbsp;        return (String)value;</b>
<i>320</i>&nbsp;      }
<i>321</i>&nbsp;      else {
<b class="nc"><i>322</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be String!&quot;);</b>
<i>323</i>&nbsp;      }
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;
<i>326</i>&nbsp;    public boolean getBool(String name) throws InvalidFormatException {
<b class="fc"><i>327</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>328</i>&nbsp;      if (value == null) {</b>
<b class="nc"><i>329</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be set!&quot;);</b>
<i>330</i>&nbsp;      }
<b class="fc"><i>331</i>&nbsp;      else if (value instanceof Boolean) {</b>
<b class="fc"><i>332</i>&nbsp;        return (Boolean)value;</b>
<i>333</i>&nbsp;      }
<i>334</i>&nbsp;      else {
<b class="nc"><i>335</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be boolean!&quot;);</b>
<i>336</i>&nbsp;      }
<i>337</i>&nbsp;    }
<i>338</i>&nbsp;
<i>339</i>&nbsp;    public boolean getBool(String name, boolean defValue) throws InvalidFormatException {
<b class="fc"><i>340</i>&nbsp;      Object value = args.get(name);</b>
<b class="fc"><i>341</i>&nbsp;      if (value == null) {</b>
<b class="fc"><i>342</i>&nbsp;        return defValue;</b>
<i>343</i>&nbsp;      }
<b class="fc"><i>344</i>&nbsp;      else if (value instanceof Boolean) {</b>
<b class="fc"><i>345</i>&nbsp;        return (Boolean)value;</b>
<i>346</i>&nbsp;      }
<i>347</i>&nbsp;      else {
<b class="nc"><i>348</i>&nbsp;        throw new InvalidFormatException(&quot;parameter &quot; + name + &quot; must be boolean!&quot;);</b>
<i>349</i>&nbsp;      }
<i>350</i>&nbsp;    }
<i>351</i>&nbsp;
<i>352</i>&nbsp;    /**
<i>353</i>&nbsp;     *
<i>354</i>&nbsp;     * @return null if the subclass uses {@link #resourceManager} to instantiate
<i>355</i>&nbsp;     * @throws InvalidFormatException
<i>356</i>&nbsp;     */
<i>357</i>&nbsp;    public abstract AdaptiveFeatureGenerator create() throws InvalidFormatException;
<i>358</i>&nbsp;  }
<i>359</i>&nbsp;
<i>360</i>&nbsp;  // TODO: We have to support custom resources here. How does it work ?!
<i>361</i>&nbsp;  // Attributes get into a Map&lt;String, String&gt; properties
<i>362</i>&nbsp;
<i>363</i>&nbsp;  // How can serialization be supported ?!
<i>364</i>&nbsp;  // The model is loaded, and the manifest should contain all serializer classes registered for the
<i>365</i>&nbsp;  // resources by name.
<i>366</i>&nbsp;  // When training, the descriptor could be consulted first to register the serializers, and afterwards
<i>367</i>&nbsp;  // they are stored in the model.
<i>368</i>&nbsp;
<i>369</i>&nbsp;  // TODO: (OPENNLP-1174) just remove this class when back-compat is no longer needed
<b class="fc"><i>370</i>&nbsp;  static class CustomFeatureGeneratorFactory implements XmlFeatureGeneratorFactory {</b>
<i>371</i>&nbsp;
<i>372</i>&nbsp;    public AdaptiveFeatureGenerator create(Element generatorElement,
<i>373</i>&nbsp;        FeatureGeneratorResourceProvider resourceManager) throws InvalidFormatException {
<i>374</i>&nbsp;
<b class="fc"><i>375</i>&nbsp;      String featureGeneratorClassName = generatorElement.getAttribute(&quot;class&quot;);</b>
<i>376</i>&nbsp;
<b class="fc"><i>377</i>&nbsp;      AdaptiveFeatureGenerator generator =</b>
<b class="fc"><i>378</i>&nbsp;          ExtensionLoader.instantiateExtension(AdaptiveFeatureGenerator.class, featureGeneratorClassName);</b>
<i>379</i>&nbsp;
<b class="fc"><i>380</i>&nbsp;      if (generator instanceof CustomFeatureGenerator) {</b>
<i>381</i>&nbsp;
<b class="fc"><i>382</i>&nbsp;        CustomFeatureGenerator customGenerator = (CustomFeatureGenerator) generator;</b>
<i>383</i>&nbsp;
<b class="fc"><i>384</i>&nbsp;        Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();</b>
<i>385</i>&nbsp;
<b class="fc"><i>386</i>&nbsp;        NamedNodeMap attributes = generatorElement.getAttributes();</b>
<i>387</i>&nbsp;
<b class="fc"><i>388</i>&nbsp;        for (int i = 0; i &lt; attributes.getLength(); i++) {</b>
<b class="fc"><i>389</i>&nbsp;          Node attribute = attributes.item(i);</b>
<b class="fc"><i>390</i>&nbsp;          if (!&quot;class&quot;.equals(attribute.getNodeName())) {</b>
<b class="nc"><i>391</i>&nbsp;            properties.put(attribute.getNodeName(), attribute.getNodeValue());</b>
<i>392</i>&nbsp;          }
<i>393</i>&nbsp;        }
<i>394</i>&nbsp;
<b class="fc"><i>395</i>&nbsp;        if (resourceManager != null) {</b>
<b class="nc"><i>396</i>&nbsp;          customGenerator.init(properties, resourceManager);</b>
<i>397</i>&nbsp;        }
<i>398</i>&nbsp;      }
<i>399</i>&nbsp;
<b class="fc"><i>400</i>&nbsp;      return generator;</b>
<i>401</i>&nbsp;    }
<i>402</i>&nbsp;
<i>403</i>&nbsp;    static void register(Map&lt;String, XmlFeatureGeneratorFactory&gt; factoryMap) {
<b class="fc"><i>404</i>&nbsp;      factoryMap.put(&quot;custom&quot;, new CustomFeatureGeneratorFactory());</b>
<b class="fc"><i>405</i>&nbsp;    }</b>
<i>406</i>&nbsp;  }
<i>407</i>&nbsp;
<i>408</i>&nbsp;  // TODO: (OPENNLP-1174) just remove when back-compat is no longer needed
<b class="fc"><i>409</i>&nbsp;  private static Map&lt;String, XmlFeatureGeneratorFactory&gt; factories = new HashMap&lt;&gt;();</b>
<i>410</i>&nbsp;
<i>411</i>&nbsp;  // TODO: (OPENNLP-1174) just remove when back-compat is no longer needed
<i>412</i>&nbsp;  static {
<b class="fc"><i>413</i>&nbsp;    AggregatedFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>414</i>&nbsp;    CachedFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>415</i>&nbsp;    CharacterNgramFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>416</i>&nbsp;    DefinitionFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>417</i>&nbsp;    DictionaryFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>418</i>&nbsp;    DocumentBeginFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>419</i>&nbsp;    PreviousMapFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>420</i>&nbsp;    SentenceFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>421</i>&nbsp;    TokenClassFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>422</i>&nbsp;    TokenFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>423</i>&nbsp;    BigramNameFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>424</i>&nbsp;    TokenPatternFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>425</i>&nbsp;    PosTaggerFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>426</i>&nbsp;    PrefixFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>427</i>&nbsp;    SuffixFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>428</i>&nbsp;    WindowFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>429</i>&nbsp;    WordClusterFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>430</i>&nbsp;    BrownClusterTokenFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>431</i>&nbsp;    BrownClusterTokenClassFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>432</i>&nbsp;    BrownClusterBigramFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>433</i>&nbsp;    CustomFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>434</i>&nbsp;    POSTaggerNameFeatureGeneratorFactory.register(factories);</b>
<b class="fc"><i>435</i>&nbsp;  }</b>
<i>436</i>&nbsp;
<i>437</i>&nbsp;  /**
<i>438</i>&nbsp;   * Creates a {@link AdaptiveFeatureGenerator} for the provided element.
<i>439</i>&nbsp;   * To accomplish this it looks up the corresponding factory by the
<i>440</i>&nbsp;   * element tag name. The factory is then responsible for the creation
<i>441</i>&nbsp;   * of the generator from the element.
<i>442</i>&nbsp;   *
<i>443</i>&nbsp;   * @param generatorElement
<i>444</i>&nbsp;   * @param resourceManager
<i>445</i>&nbsp;   *
<i>446</i>&nbsp;   * @return
<i>447</i>&nbsp;   */
<i>448</i>&nbsp;  @Deprecated   // TODO: (OPENNLP-1174) remove back-compat support when it is unnecessary
<i>449</i>&nbsp;  static AdaptiveFeatureGenerator createGenerator(Element generatorElement,
<i>450</i>&nbsp;      FeatureGeneratorResourceProvider resourceManager) throws InvalidFormatException {
<i>451</i>&nbsp;
<b class="fc"><i>452</i>&nbsp;    String elementName = generatorElement.getTagName();</b>
<i>453</i>&nbsp;
<i>454</i>&nbsp;    // check it is new format?
<b class="fc"><i>455</i>&nbsp;    if (elementName.equals(&quot;featureGenerators&quot;)) {</b>
<i>456</i>&nbsp;
<b class="fc"><i>457</i>&nbsp;      List&lt;AdaptiveFeatureGenerator&gt; generators = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>458</i>&nbsp;      NodeList childNodes = generatorElement.getChildNodes();</b>
<b class="fc"><i>459</i>&nbsp;      for (int i = 0; i &lt; childNodes.getLength(); i++) {</b>
<b class="fc"><i>460</i>&nbsp;        Node childNode = childNodes.item(i);</b>
<b class="fc"><i>461</i>&nbsp;        if (childNode instanceof Element) {</b>
<b class="fc"><i>462</i>&nbsp;          Element elem = (Element)childNode;</b>
<b class="fc"><i>463</i>&nbsp;          String type = elem.getTagName();</b>
<b class="fc"><i>464</i>&nbsp;          if (type.equals(&quot;generator&quot;)) {</b>
<b class="fc"><i>465</i>&nbsp;            generators.add(buildGenerator(elem, resourceManager));</b>
<i>466</i>&nbsp;          }
<i>467</i>&nbsp;          else
<b class="fc"><i>468</i>&nbsp;            throw new InvalidFormatException(&quot;Unexpected element: &quot; + elementName);</b>
<i>469</i>&nbsp;        }
<i>470</i>&nbsp;      }
<i>471</i>&nbsp;
<b class="fc"><i>472</i>&nbsp;      AdaptiveFeatureGenerator featureGenerator = null;</b>
<b class="fc"><i>473</i>&nbsp;      if (generators.size() == 1)</b>
<b class="fc"><i>474</i>&nbsp;        featureGenerator = generators.get(0);</b>
<b class="fc"><i>475</i>&nbsp;      else if (generators.size() &gt; 1)</b>
<b class="fc"><i>476</i>&nbsp;        featureGenerator = new AggregatedFeatureGenerator(generators.toArray(</b>
<b class="fc"><i>477</i>&nbsp;            new AdaptiveFeatureGenerator[generators.size()]));</b>
<i>478</i>&nbsp;      else
<b class="nc"><i>479</i>&nbsp;        throw new InvalidFormatException(&quot;featureGenerators must have one or more generators&quot;);</b>
<i>480</i>&nbsp;
<i>481</i>&nbsp;      // disallow manually specifying CachedFeatureGenerator
<b class="fc"><i>482</i>&nbsp;      if (featureGenerator instanceof CachedFeatureGenerator)</b>
<b class="nc"><i>483</i>&nbsp;        throw new InvalidFormatException(&quot;CachedFeatureGeneratorFactory cannot be specified manually.&quot; +</b>
<i>484</i>&nbsp;          &quot;Use cache=\&quot;true\&quot; attribute in featureGenerators element instead.&quot;);
<i>485</i>&nbsp;
<i>486</i>&nbsp;      // check cache usage
<b class="fc"><i>487</i>&nbsp;      if (Boolean.parseBoolean(generatorElement.getAttribute(&quot;cache&quot;)))</b>
<b class="fc"><i>488</i>&nbsp;        return new CachedFeatureGenerator(featureGenerator);</b>
<i>489</i>&nbsp;      else
<b class="fc"><i>490</i>&nbsp;        return featureGenerator;</b>
<i>491</i>&nbsp;    }
<i>492</i>&nbsp;    else {
<i>493</i>&nbsp;      // support classic format
<b class="fc"><i>494</i>&nbsp;      XmlFeatureGeneratorFactory generatorFactory = factories.get(elementName);</b>
<b class="fc"><i>495</i>&nbsp;      if (generatorFactory != null) {</b>
<b class="fc"><i>496</i>&nbsp;        return generatorFactory.create(generatorElement, resourceManager);</b>
<i>497</i>&nbsp;      }
<i>498</i>&nbsp;      else
<b class="fc"><i>499</i>&nbsp;        throw new InvalidFormatException(&quot;Unexpected element: &quot; + elementName);</b>
<i>500</i>&nbsp;    }
<i>501</i>&nbsp;  }
<i>502</i>&nbsp;
<i>503</i>&nbsp;  static Element getFirstChild(Element elem) {
<b class="nc"><i>504</i>&nbsp;    NodeList nodes = elem.getChildNodes();</b>
<b class="nc"><i>505</i>&nbsp;    for (int i = 0; i &lt; nodes.getLength(); i++) {</b>
<b class="nc"><i>506</i>&nbsp;      if (nodes.item(i) instanceof Element) {</b>
<b class="nc"><i>507</i>&nbsp;        return (Element)nodes.item(i);</b>
<i>508</i>&nbsp;      }
<i>509</i>&nbsp;    }
<b class="nc"><i>510</i>&nbsp;    return null;</b>
<i>511</i>&nbsp;  }
<i>512</i>&nbsp;
<i>513</i>&nbsp;  /**
<i>514</i>&nbsp;   * Creates a {@link AdaptiveFeatureGenerator} for the provided element.
<i>515</i>&nbsp;   * To accomplish this it looks up the corresponding factory by the
<i>516</i>&nbsp;   * element tag name. The factory is then responsible for the creation
<i>517</i>&nbsp;   * of the generator from the element.
<i>518</i>&nbsp;   *
<i>519</i>&nbsp;   * @param generatorElement
<i>520</i>&nbsp;   * @param resourceManager
<i>521</i>&nbsp;   *
<i>522</i>&nbsp;   * @return
<i>523</i>&nbsp;   */
<i>524</i>&nbsp;  static AdaptiveFeatureGenerator buildGenerator(Element generatorElement,
<i>525</i>&nbsp;             FeatureGeneratorResourceProvider resourceManager) throws InvalidFormatException {
<b class="fc"><i>526</i>&nbsp;    String className = generatorElement.getAttribute(&quot;class&quot;);</b>
<b class="fc"><i>527</i>&nbsp;    if (className == null) {</b>
<b class="nc"><i>528</i>&nbsp;      throw new InvalidFormatException(&quot;generator must have class attribute&quot;);</b>
<i>529</i>&nbsp;    }
<i>530</i>&nbsp;    else {
<i>531</i>&nbsp;      try {
<b class="fc"><i>532</i>&nbsp;        Class factoryClass = Class.forName(className);</b>
<i>533</i>&nbsp;        try {
<b class="fc"><i>534</i>&nbsp;          Constructor constructor = factoryClass.getConstructor();</b>
<b class="fc"><i>535</i>&nbsp;          AbstractXmlFeatureGeneratorFactory factory =</b>
<b class="fc"><i>536</i>&nbsp;              (AbstractXmlFeatureGeneratorFactory)constructor.newInstance();</b>
<b class="fc"><i>537</i>&nbsp;          factory.init(generatorElement, resourceManager);</b>
<b class="fc"><i>538</i>&nbsp;          return factory.create();</b>
<b class="nc"><i>539</i>&nbsp;        } catch (NoSuchMethodException e) {</b>
<b class="nc"><i>540</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>541</i>&nbsp;        } catch (InvocationTargetException e) {</b>
<b class="nc"><i>542</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>543</i>&nbsp;        } catch (InstantiationException e) {</b>
<b class="nc"><i>544</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>545</i>&nbsp;        } catch (IllegalAccessException e) {</b>
<b class="nc"><i>546</i>&nbsp;          throw new RuntimeException(e);</b>
<i>547</i>&nbsp;        }
<b class="nc"><i>548</i>&nbsp;      } catch (ClassNotFoundException e) {</b>
<b class="nc"><i>549</i>&nbsp;        throw new RuntimeException(e);</b>
<i>550</i>&nbsp;      }
<i>551</i>&nbsp;    }
<i>552</i>&nbsp;  }
<i>553</i>&nbsp;
<i>554</i>&nbsp;  private static org.w3c.dom.Document createDOM(InputStream xmlDescriptorIn)
<i>555</i>&nbsp;      throws IOException {
<i>556</i>&nbsp;
<b class="fc"><i>557</i>&nbsp;    DocumentBuilder documentBuilder = XmlUtil.createDocumentBuilder();</b>
<i>558</i>&nbsp;
<i>559</i>&nbsp;    org.w3c.dom.Document xmlDescriptorDOM;
<i>560</i>&nbsp;
<i>561</i>&nbsp;    try {
<b class="fc"><i>562</i>&nbsp;      xmlDescriptorDOM = documentBuilder.parse(xmlDescriptorIn);</b>
<b class="nc"><i>563</i>&nbsp;    } catch (SAXException e) {</b>
<b class="nc"><i>564</i>&nbsp;      throw new InvalidFormatException(&quot;Descriptor is not valid XML!&quot;, e);</b>
<b class="fc"><i>565</i>&nbsp;    }</b>
<b class="fc"><i>566</i>&nbsp;    return xmlDescriptorDOM;</b>
<i>567</i>&nbsp;  }
<i>568</i>&nbsp;
<i>569</i>&nbsp;  /**
<i>570</i>&nbsp;   * Creates an {@link AdaptiveFeatureGenerator} from an provided XML descriptor.
<i>571</i>&nbsp;   *
<i>572</i>&nbsp;   * Usually this XML descriptor contains a set of nested feature generators
<i>573</i>&nbsp;   * which are then used to generate the features by one of the opennlp
<i>574</i>&nbsp;   * components.
<i>575</i>&nbsp;   *
<i>576</i>&nbsp;   * @param xmlDescriptorIn the {@link InputStream} from which the descriptor
<i>577</i>&nbsp;   *     is read, the stream remains open and must be closed by the caller.
<i>578</i>&nbsp;   *
<i>579</i>&nbsp;   * @param resourceManager the resource manager which is used to resolve resources
<i>580</i>&nbsp;   *     referenced by a key in the descriptor
<i>581</i>&nbsp;   *
<i>582</i>&nbsp;   * @return created feature generators
<i>583</i>&nbsp;   *
<i>584</i>&nbsp;   * @throws IOException if an error occurs during reading from the descriptor
<i>585</i>&nbsp;   *     {@link InputStream}
<i>586</i>&nbsp;   */
<i>587</i>&nbsp;  public static AdaptiveFeatureGenerator create(InputStream xmlDescriptorIn,
<i>588</i>&nbsp;      FeatureGeneratorResourceProvider resourceManager) throws IOException {
<i>589</i>&nbsp;
<b class="fc"><i>590</i>&nbsp;    org.w3c.dom.Document xmlDescriptorDOM = createDOM(xmlDescriptorIn);</b>
<i>591</i>&nbsp;
<b class="fc"><i>592</i>&nbsp;    Element generatorElement = xmlDescriptorDOM.getDocumentElement();</b>
<i>593</i>&nbsp;
<i>594</i>&nbsp;    // TODO: (OPENNLP-1174) use #buildGenerator() after back-compat support is gone
<b class="fc"><i>595</i>&nbsp;    return createGenerator(generatorElement, resourceManager);</b>
<i>596</i>&nbsp;  }
<i>597</i>&nbsp;
<i>598</i>&nbsp;  public static Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; extractArtifactSerializerMappings(
<i>599</i>&nbsp;      InputStream xmlDescriptorIn) throws IOException {
<i>600</i>&nbsp;
<b class="fc"><i>601</i>&nbsp;    org.w3c.dom.Document xmlDescriptorDOM = createDOM(xmlDescriptorIn);</b>
<b class="fc"><i>602</i>&nbsp;    Element element = xmlDescriptorDOM.getDocumentElement();</b>
<i>603</i>&nbsp;
<b class="fc"><i>604</i>&nbsp;    String elementName = element.getTagName();</b>
<i>605</i>&nbsp;
<i>606</i>&nbsp;    // check it is new format?
<b class="fc"><i>607</i>&nbsp;    if (elementName.equals(&quot;featureGenerators&quot;)) {</b>
<b class="fc"><i>608</i>&nbsp;      Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; mapping = new HashMap&lt;&gt;();</b>
<b class="fc"><i>609</i>&nbsp;      NodeList nodes = element.getChildNodes();</b>
<b class="fc"><i>610</i>&nbsp;      for (int i = 0; i &lt; nodes.getLength(); i++) {</b>
<b class="fc"><i>611</i>&nbsp;        if (nodes.item(i) instanceof Element) {</b>
<b class="fc"><i>612</i>&nbsp;          Element childElem = (Element)nodes.item(i);</b>
<b class="fc"><i>613</i>&nbsp;          if (childElem.getTagName().equals(&quot;generator&quot;)) {</b>
<b class="fc"><i>614</i>&nbsp;            extractArtifactSerializerMappings(mapping, childElem);</b>
<i>615</i>&nbsp;          }
<i>616</i>&nbsp;        }
<i>617</i>&nbsp;      }
<b class="fc"><i>618</i>&nbsp;      return mapping;</b>
<i>619</i>&nbsp;    }
<i>620</i>&nbsp;    else {
<b class="fc"><i>621</i>&nbsp;      return extractArtifactSerializerMappingsClassicFormat(element);</b>
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;  }
<i>624</i>&nbsp;
<i>625</i>&nbsp;  static void extractArtifactSerializerMappings(Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; mapping, Element element) {
<b class="fc"><i>626</i>&nbsp;    String className = element.getAttribute(&quot;class&quot;);</b>
<b class="fc"><i>627</i>&nbsp;    if (className != null) {</b>
<i>628</i>&nbsp;      try {
<b class="fc"><i>629</i>&nbsp;        Class factoryClass = Class.forName(className);</b>
<i>630</i>&nbsp;        try {
<b class="fc"><i>631</i>&nbsp;          Constructor constructor = factoryClass.getConstructor();</b>
<b class="fc"><i>632</i>&nbsp;          AbstractXmlFeatureGeneratorFactory factory =</b>
<b class="fc"><i>633</i>&nbsp;              (AbstractXmlFeatureGeneratorFactory)constructor.newInstance();</b>
<b class="fc"><i>634</i>&nbsp;          factory.init(element, null);</b>
<b class="fc"><i>635</i>&nbsp;          Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; map = factory.getArtifactSerializerMapping();</b>
<b class="fc"><i>636</i>&nbsp;          if (map != null)</b>
<b class="fc"><i>637</i>&nbsp;            mapping.putAll(map);</b>
<b class="nc"><i>638</i>&nbsp;        } catch (NoSuchMethodException e) {</b>
<b class="nc"><i>639</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>640</i>&nbsp;        } catch (InvocationTargetException e) {</b>
<b class="nc"><i>641</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>642</i>&nbsp;        } catch (InstantiationException e) {</b>
<b class="nc"><i>643</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>644</i>&nbsp;        } catch (IllegalAccessException e) {</b>
<b class="nc"><i>645</i>&nbsp;          throw new RuntimeException(e);</b>
<b class="nc"><i>646</i>&nbsp;        } catch (InvalidFormatException ignored) {</b>
<b class="fc"><i>647</i>&nbsp;        }</b>
<b class="nc"><i>648</i>&nbsp;      } catch (ClassNotFoundException e) {</b>
<b class="nc"><i>649</i>&nbsp;        throw new RuntimeException(e);</b>
<b class="fc"><i>650</i>&nbsp;      }</b>
<i>651</i>&nbsp;    }
<i>652</i>&nbsp;
<b class="fc"><i>653</i>&nbsp;    NodeList nodes = element.getChildNodes();</b>
<b class="fc"><i>654</i>&nbsp;    for (int i = 0; i &lt; nodes.getLength(); i++) {</b>
<b class="fc"><i>655</i>&nbsp;      if (nodes.item(i) instanceof Element) {</b>
<b class="fc"><i>656</i>&nbsp;        Element childElem = (Element)nodes.item(i);</b>
<b class="fc"><i>657</i>&nbsp;        if (childElem.getTagName().equals(&quot;generator&quot;)) {</b>
<b class="fc"><i>658</i>&nbsp;          extractArtifactSerializerMappings(mapping, childElem);</b>
<i>659</i>&nbsp;        }
<i>660</i>&nbsp;      }
<i>661</i>&nbsp;    }
<b class="fc"><i>662</i>&nbsp;  }</b>
<i>663</i>&nbsp;
<i>664</i>&nbsp;  @Deprecated   // TODO: (OPENNLP-1174) remove back-compat support when it is unnecessary
<i>665</i>&nbsp;  static Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; extractArtifactSerializerMappingsClassicFormat(
<i>666</i>&nbsp;      Element elem) throws IOException {
<b class="fc"><i>667</i>&nbsp;    Map&lt;String, ArtifactSerializer&lt;?&gt;&gt; mapping = new HashMap&lt;&gt;();</b>
<i>668</i>&nbsp;
<b class="fc"><i>669</i>&nbsp;    XPath xPath = XPathFactory.newInstance().newXPath();</b>
<i>670</i>&nbsp;
<i>671</i>&nbsp;    NodeList customElements;
<i>672</i>&nbsp;    try {
<b class="fc"><i>673</i>&nbsp;      XPathExpression exp = xPath.compile(&quot;//custom&quot;);</b>
<b class="fc"><i>674</i>&nbsp;      customElements = (NodeList) exp.evaluate(elem, XPathConstants.NODESET);</b>
<b class="nc"><i>675</i>&nbsp;    } catch (XPathExpressionException e) {</b>
<b class="nc"><i>676</i>&nbsp;      throw new IllegalStateException(&quot;The hard coded XPath expression should always be valid!&quot;);</b>
<b class="fc"><i>677</i>&nbsp;    }</b>
<i>678</i>&nbsp;
<b class="fc"><i>679</i>&nbsp;    for (int i = 0; i &lt; customElements.getLength(); i++) {</b>
<b class="fc"><i>680</i>&nbsp;      if (customElements.item(i) instanceof Element) {</b>
<b class="fc"><i>681</i>&nbsp;        Element customElement = (Element) customElements.item(i);</b>
<i>682</i>&nbsp;
<i>683</i>&nbsp;        // Note: The resource provider is not available at that point, to provide
<i>684</i>&nbsp;        // resources they need to be loaded first!
<b class="fc"><i>685</i>&nbsp;        AdaptiveFeatureGenerator generator = createGenerator(customElement, null);</b>
<i>686</i>&nbsp;
<b class="fc"><i>687</i>&nbsp;        if (generator instanceof ArtifactToSerializerMapper) {</b>
<b class="fc"><i>688</i>&nbsp;          ArtifactToSerializerMapper mapper = (ArtifactToSerializerMapper) generator;</b>
<b class="fc"><i>689</i>&nbsp;          mapping.putAll(mapper.getArtifactSerializerMapping());</b>
<i>690</i>&nbsp;        }
<i>691</i>&nbsp;      }
<i>692</i>&nbsp;    }
<i>693</i>&nbsp;
<i>694</i>&nbsp;    NodeList allElements;
<i>695</i>&nbsp;    try {
<b class="fc"><i>696</i>&nbsp;      XPathExpression exp = xPath.compile(&quot;//*&quot;);</b>
<b class="fc"><i>697</i>&nbsp;      allElements = (NodeList) exp.evaluate(elem, XPathConstants.NODESET);</b>
<b class="nc"><i>698</i>&nbsp;    } catch (XPathExpressionException e) {</b>
<b class="nc"><i>699</i>&nbsp;      throw new IllegalStateException(&quot;The hard coded XPath expression should always be valid!&quot;);</b>
<b class="fc"><i>700</i>&nbsp;    }</b>
<i>701</i>&nbsp;
<b class="fc"><i>702</i>&nbsp;    for (int i = 0; i &lt; allElements.getLength(); i++) {</b>
<b class="fc"><i>703</i>&nbsp;      if (allElements.item(i) instanceof Element) {</b>
<b class="fc"><i>704</i>&nbsp;        Element xmlElement = (Element) allElements.item(i);</b>
<i>705</i>&nbsp;
<b class="fc"><i>706</i>&nbsp;        String dictName = xmlElement.getAttribute(&quot;dict&quot;);</b>
<b class="fc"><i>707</i>&nbsp;        if (dictName != null) {</b>
<i>708</i>&nbsp;
<b class="fc"><i>709</i>&nbsp;          switch (xmlElement.getTagName()) {</b>
<i>710</i>&nbsp;            case &quot;wordcluster&quot;:
<b class="nc"><i>711</i>&nbsp;              mapping.put(dictName, new WordClusterDictionary.WordClusterDictionarySerializer());</b>
<b class="nc"><i>712</i>&nbsp;              break;</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;            case &quot;brownclustertoken&quot;:
<b class="nc"><i>715</i>&nbsp;              mapping.put(dictName, new BrownCluster.BrownClusterSerializer());</b>
<b class="nc"><i>716</i>&nbsp;              break;</b>
<i>717</i>&nbsp;
<i>718</i>&nbsp;            case &quot;brownclustertokenclass&quot;://, ;
<b class="nc"><i>719</i>&nbsp;              mapping.put(dictName, new BrownCluster.BrownClusterSerializer());</b>
<b class="nc"><i>720</i>&nbsp;              break;</b>
<i>721</i>&nbsp;
<i>722</i>&nbsp;            case &quot;brownclusterbigram&quot;: //, ;
<b class="nc"><i>723</i>&nbsp;              mapping.put(dictName, new BrownCluster.BrownClusterSerializer());</b>
<b class="nc"><i>724</i>&nbsp;              break;</b>
<i>725</i>&nbsp;
<i>726</i>&nbsp;            case &quot;dictionary&quot;:
<b class="fc"><i>727</i>&nbsp;              mapping.put(dictName, new DictionarySerializer());</b>
<i>728</i>&nbsp;              break;
<i>729</i>&nbsp;          }
<i>730</i>&nbsp;        }
<i>731</i>&nbsp;
<b class="fc"><i>732</i>&nbsp;        String modelName = xmlElement.getAttribute(&quot;model&quot;);</b>
<b class="fc"><i>733</i>&nbsp;        if (modelName != null) {</b>
<i>734</i>&nbsp;
<b class="fc"><i>735</i>&nbsp;          switch (xmlElement.getTagName()) {</b>
<i>736</i>&nbsp;            case &quot;tokenpos&quot;:
<b class="nc"><i>737</i>&nbsp;              mapping.put(modelName, new POSModelSerializer());</b>
<i>738</i>&nbsp;              break;
<i>739</i>&nbsp;          }
<i>740</i>&nbsp;        }
<i>741</i>&nbsp;      }
<i>742</i>&nbsp;    }
<i>743</i>&nbsp;
<b class="fc"><i>744</i>&nbsp;    return mapping;</b>
<i>745</i>&nbsp;  }
<i>746</i>&nbsp;
<i>747</i>&nbsp;  /**
<i>748</i>&nbsp;   * Provides a list with all the elements in the xml feature descriptor.
<i>749</i>&nbsp;   * @param xmlDescriptorIn the xml feature descriptor
<i>750</i>&nbsp;   * @return a list containing all elements
<i>751</i>&nbsp;   * @throws IOException if inputstream cannot be open
<i>752</i>&nbsp;   * @throws InvalidFormatException if xml is not well-formed
<i>753</i>&nbsp;   */
<i>754</i>&nbsp;  public static List&lt;Element&gt; getDescriptorElements(InputStream xmlDescriptorIn)
<i>755</i>&nbsp;      throws IOException {
<i>756</i>&nbsp;
<b class="nc"><i>757</i>&nbsp;    List&lt;Element&gt; elements = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>758</i>&nbsp;    org.w3c.dom.Document xmlDescriptorDOM = createDOM(xmlDescriptorIn);</b>
<b class="nc"><i>759</i>&nbsp;    XPath xPath = XPathFactory.newInstance().newXPath();</b>
<i>760</i>&nbsp;    NodeList allElements;
<i>761</i>&nbsp;    try {
<b class="nc"><i>762</i>&nbsp;      XPathExpression exp = xPath.compile(&quot;//*&quot;);</b>
<b class="nc"><i>763</i>&nbsp;      allElements = (NodeList) exp.evaluate(xmlDescriptorDOM.getDocumentElement(), XPathConstants.NODESET);</b>
<b class="nc"><i>764</i>&nbsp;    } catch (XPathExpressionException e) {</b>
<b class="nc"><i>765</i>&nbsp;      throw new IllegalStateException(&quot;The hard coded XPath expression should always be valid!&quot;);</b>
<b class="nc"><i>766</i>&nbsp;    }</b>
<i>767</i>&nbsp;
<b class="nc"><i>768</i>&nbsp;    for (int i = 0; i &lt; allElements.getLength(); i++) {</b>
<b class="nc"><i>769</i>&nbsp;      if (allElements.item(i) instanceof Element) {</b>
<b class="nc"><i>770</i>&nbsp;        Element customElement = (Element) allElements.item(i);</b>
<b class="nc"><i>771</i>&nbsp;        elements.add(customElement);</b>
<i>772</i>&nbsp;      }
<i>773</i>&nbsp;    }
<b class="nc"><i>774</i>&nbsp;    return elements;</b>
<i>775</i>&nbsp;  }
<i>776</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-05-09 18:47</div>
</div>
</body>
</html>
